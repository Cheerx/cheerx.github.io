---
layout: post
title: "[工具]Git常用技巧"
image: git-unsplash.jpg
image-origin: "Photo by Yancy Min on Unsplash"
---

>Git is the force!

# Overview

[Git](https://git-scm.com/)是Linus Torvalds早年为Linux内核的开发版本控制工具，但是，现在Git已经不只是为Linux内核服务，而是成为了几乎所有类型的项目的首选版本控制工具（所以对于周围好多同事完全没用过Git还是很惊讶的）。由于没有长期使用过其他的版本控制工具所以不好评价其相对于其他版本控制工具的优劣，只是对于Git相对于SVN的超快下载速度有深刻的映像，而且目前为止Git的一切都很让我满意。本文不会讲类似于`git add/commit/pull/push`这种基础的操作，而是分享一些平时经常会用到的提升效率的操作。而对于Git的协作模式，本文也不会涉及，因为毕竟对于这种软件工程类的问题还没有那么深刻的理解，看过一篇对于常见的*Git Flow*，*Github flow*，*Gitlab flow*的介绍的文章，觉得写得比较清楚，[Git开发协作方法调研](https://mp.weixin.qq.com/s/ChPOsPQAaXfvqLwDb7OtBw)。

<!--more-->

## Git基础原理

Git的基础原理不是那么好讲清楚，本文只在这里简单的描述一下，可能便于后面的理解。

首先，Git最核心的特点是仓库中每一次记录都是一份数据的快照，而不是数据变化的delta，当然为了高效，如果一个文件没有变化则新的记录里只会保留对之前存储的文件的链接。如下图所示，可以看出每一个版本（对应每一次提交记录）都有完整的数据，其中文件B在*Version 2*和*Version 3*中没有变化则保存的是对*Version 1*文件的链接。
![Git Versions](assets/img/git-usage/git_versions.png)
> 图片来自于《ProGit》一书，这是学习Git的最好材料

其次，Git没有中心服务器的概念，也就是一旦仓库被克隆到本地那么本地就拥有该仓库完整的所有信息，如文件和历史记录等，这意味着我们在Git仓库中执行的几乎所有操作都是在本地执行的，因此速度也是非常快的，而且离线状态下也是可以操作的。

还有一点非常重要的，Git管理的项目中，你的工作目录中的文件有这3种状态：已修改（modified）、已暂存（staged）和已提交（commited）。已修改表示工作目录中的文件只是被修改了；已暂存表示修改的文件已经被标记了，可以被提交到仓库中了；已提交表示数据已经被提交到仓库里了。对应的也就有了3个工作区：工作目录、暂存区和Git仓库，如下图所示。
![Git空间](assets/img/git-usage/git_space.png)
> 图片来自于《ProGit》一书

Git仓库目录是Git用来保存项目的元数据和对象数据库的地方，也就是我们的*.git*目录。这是Git中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。工作目录是对项目的某个版本独立提取出来的内容，就是我们日常看到的我们工程的代码所在的目录。 这些从Git仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在Git仓库目录中。 有时候也被称作“索引”，不过一般说法还是叫暂存区域。

## Git高级技巧

### Git仓库的创建

这里说的Git仓库的创建不是指在GitHub上创建一个仓库，而是说在随便一个服务器甚至是一台普通主机上创建一个仓库，因为对于我们协作开发来讲一台公共可访问的机器就够了。为了满足这样的需求我们需要一个**裸仓库**，也就是只有Git元数据和对象数据的仓库，创建的方式十分简单，可以通过`git clone --bare <exist repo>`基于已经存在的Git仓库来创建，也可以通过`git init --bare <repo name>`创建一个全新的仓库。这样创建的仓库可能还不能满足多人协作开发的要求，需要在创建时加上`--shared`参数来配置组内的写权限，如`git init --bare --shared <repo name>`。不过这样创建的仓库还是只适合于只有少数几个人的项目，而如果需要公共读权限或者很多人的写权限，或者网页等则还是用GitHub或Gitlab吧。

### 分支合并

分支合并是一个再常见不过的场景了，比如我们从*master*切到了我们自己的*dev-self*分支上开发，然后在提交前我们需要先跟*master*分支合并一次，这个时候需要先切到*master*上将其更新了，再回到我们的*dev-self*分支上合并。此时有两种操作方法，第一种是常规的`git merge master`，另一种是`git rebase master`，这两种方法的区别通过这两张图就可以看出来。
![Git merge](assets/img/git-usage/git_merge.png)

![Git rebase](assets/img/git-usage/git_rebase.png)
第一张图是`git merge master`之后的Git历史记录的信息，第二张图是`git rebase master`之后的Git历史记录信息，可以看到二者都成功的合并了*master*分支上的内容，但是差别就在*merge*方式合并的比*rebase*方式合并的历史记录里多了一条合并的记录，这条记录在这里或许显得影响不大，但是对于经常发生分支合并的仓库影响就十分巨大，会导致历史记录显得十分难看，而保持大型仓库历史记录的整洁也是非常重要的。所以推荐分支合并首选`git rebase`。By the way，`git rebase`不仅可以用来合并分支还可以用来合并commit、修改commit message等。

### 临时存储当前分支修改

临时存储当前分支的修改是一项非常有用的功能，试想当前你的功能在这个分支上正做到一半，突然领导要求马上修复另一个bug，这时候你肯定不可能在当前分支上修复，而是应该切到一个新的分支上去做，但是当前的分支又有很多已修改，总不能把这个半拉子提交吧，这时候`git stash`就派上用场了。先用`git stash push -m "<msg>"`把当前分支的已修改保存起来，这个时候当前分支会恢复到*HEAD*的记录，然后切到新分支修bug，完了切回来用`git stash pop <stash id>`恢复之前保存的现场继续开发。

Git的功能十分强大，还有很多有用的功能如bisect、hook等，用好了真的是开发、解bug神器，再重申一次Nicholas教授说的话：**Git is the force!**
